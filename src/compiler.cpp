#include "compiler.h"

#include <sstream>

#include "colors.h"

namespace up
{
    Compiler::Compiler()
        : scanner(*this), parser(scanner, *this)
    {}

    Compiler::~Compiler()
    {
        clearFunctions();
    }

    int Compiler::parse(const std::string &FILE_PATH)
    {
        // Init variables
        program = "";
        generationError = false;
        modules.clear();
        clearFunctions();
        functions.push_back(UpFunction::createMain());

        // Scan
        int ret = 0;
        ret = scan(FILE_PATH);

        if (ret != 0)
            return ret;

        // TODO : Remove
        cout << "Program parsed\n";

        // Generate
        generate();

        if (generationError)
            return 1;

        // TODO : Write into a file
        cout << "Transpiled program :\n\n";
        cout << program;

        return ret;
    }
    
    void Compiler::import(const Module &MOD)
    {
        // Special module that gathers multiple modules
        if (MOD.name == "libc")
        {
            modules.push_back(Module("stdio", false));
            modules.push_back(Module("stdlib", false));
            modules.push_back(Module("math", false));
        }
        else
            modules.push_back(MOD);
    }

    void Compiler::generateError(const string &MSG, const ErrorInfo &INFO)
    {
        generationError = true;

        cerr << "File " << YELLOW << INFO.file << DEFAULT <<
            ":" << BLUE << INFO.line << DEFAULT << ":" << BLUE << INFO.column << DEFAULT <<
            " - " << RED << "Generation Error" << DEFAULT << " :\n" << MSG << '\n';
    }

    Function *Compiler::getFunction(const std::string &ID, const std::vector<std::string> &ARG_TYPES)
    {
        bool isEllipsis = ARG_TYPES.size() == 1 && ARG_TYPES[0] == "...";

        for (auto f : functions)
            // TODO : Verify arg types (with implicit casts)
            if (f->id == ID)
                if (isEllipsis || (f->args.size() == 1 && f->args[0]->isEllipsis()) ||
                    f->args.size() == ARG_TYPES.size())
                    return f;

        // Not found
        return nullptr;
    }

    int Compiler::scan(const std::string &FILE_PATH)
    {
        if (!scanner.beginParse(FILE_PATH))
        {
            scanner.endParse();
            return -1;
        }

        int ret = parser.parse();

        scanner.endParse();

        return ret;
    }

    void Compiler::generate()
    {
        // Header //
        program += "// Code generated by the Up compiler\n\n";

        // Includes //
        // Add all imports at the head of the source file
        parseModules();
        program += '\n';

        // Functions //
        // TODO : Create depedencies on functions which use other functions (add signature)

        // Process functions
        for (auto f : functions)
            f->process(this);

        // Don't stringify program if there are errors
        if (generationError)
            return;

        // Generate all functions
        for (size_t i = 1; i < functions.size(); ++i)
            if (!functions[i]->isCDef)
                program += functions[i]->toString() + "\n";
        
        // Add the main function at the end
        program += main()->toString();
    }

    void Compiler::parseModules()
    {
        // TODO : Parse module names (convert to path)

        // Parse up files
        for (size_t i = 0; i < modules.size(); i++)
            if (modules[i].up)
                // TODO : Parse
                cout << "Up source to parse (WIP) : " << modules[i].name << '\n';

        // Include c files
        for (size_t i = 0; i < modules.size(); i++)
            if (!modules[i].up)
                program += "#include \"" + modules[i].name + ".h\"\n";
    }

    void Compiler::clearFunctions()
    {
        for (auto f : functions)
            delete f;
        
        functions.clear();
    }
} // namespace up
